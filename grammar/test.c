#include <stdio.h> // 전처리기 = 컴파일 하기전에 미리 처리해야 하는 명령어.
// #include 는 <> 를 컴파일 하기전에 처리하라는 의미
// python import 같은거 컴파일 하기전에 import 에 있는 라이브러리를 가지고 와서 사용한다.

// stdin.h -> .h 는 헤더파일을 의미 한다.
// 헤더 파일이라는건 이미 만들어져있는 함수가 어떤게 있는지 정리한 목차.
// 그럼 이 헤더파일을 왜 컴파일 전에 불러오나?
// 말 그대로 c언어 코드를 컴파일하기위해 컴퓨터는 stdio 안에 있는 함수들이 존재하는지 컴퓨터가 확인하면서
// 존재한다면 기능을 가지고 오고 존재하지 않는다면 가지고 오지 않는 이런 기능을 수행할 수 있다.
// 정리하자면 include 전처리기 명령어로 <stdio.h> 파일을 가지고 와서
// 안에 있는 함수들을 사용한다고 보면된다.

// stdio 의미는 = Standard input output 표준 입출력 헤더파일이라고 이야기하며
// 입출력, 반복문, 조건문 흔히 코드를 작성할때 필수적으로 사용하는 함수들이 존재한다고 보면된다.


// c언어의 가장 기본적인 함수는 main() 함수이다 실행 버튼을 누르면
// main 함수안에 있는 코드가 제일 먼저 실행 됩니다.

// return 이라는 값은 함수안에 있는 코드가 다 종료되었을때 어떠한 값을 리턴하는 즉 돌려주는 역할을 합니다.


// 선언 후 대입

// 선언 과 동시에 대입


// 특수 문자 앞에는 언제나 "\" 이게 와야 한다.

int main() {

	int num01, num02;
	printf("첫 번째 정수를 입력하세요 :");
	scanf("%d", &num01);
	printf("두 번째 정수를 입력하세요 :");
	// 입력을 받을때 사용하는 & 는 주소연산자 라고 한다
	// 주소연산자가 뜻하는 의미는 & 다음에 나오는 num01 에 변수 값을 대입하라는 의미.

	scanf("%d", &num02);

	printf("입력하신 두 정수의 합 은%d 입니다. \n", num01 + num02);
	return 0;

	scanf("%d %d", &num01, &num02);
	// 변수는 기본적으로 메모리의 주소를 기억하는 역할을 한다
	// 메모리 주소가 뭐냐면 물리적인 저장공간의 대한 주소라고 생각하면 된다.
	// 물리적인 공간의 해당 데이터가 어떤 주소에 기록되어 있는지 알기 위해서
	// 변수는 메모리주소를 통해서 해당 데이터를 식별한다.

	// 그래서 변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 된다.
	// 따라서 변수는 데이터가 저장된 메모리의 주소 뿐만이 아닌 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억한다.
	

	// 변수와 다른점을 가지고 있는 상수 는 우리가 흔히 값의 변경이 불가능하다고 많이 알고 있다.
	// 변수도 메모리주소와 데이터의 형태, 길이 정보 등을 가지고 있듯이
	// 상수 또한 데이터를 저장할 수 있는 메모리 공간인건 마찬가지다
	// 상수를 표현하는 방식은 c에서 두가지가 있는데

	// 하나는 리터럴 상수
	// 두번째는 심볼릭 상수


	// 리터럴 상수는 변수와 달리 저장된 메모리 공간을 가르키는 메모리 주소를 가지고 있지 않다.
	// 리터럴 상수는 정수형 리터럴 상수, 실수형, 문자형 등으로 구분한다.
	123, "a", 1.23 -> 이런게 리터럴 상수

	// 심볼릭 상수
	const int max = 10;
	// #define 선행처리 지시자를 이용한 매크로 심볼릭 상수
	#define max 10;

	// 항상 변수앞에 데이터 타입을 명시하게 되는데
	// 각각의 데이터를 담을 수 있는 최댓값을 고려해야

	// 오버플로우가 나지 않는다
	// 오버플로우라는건 해당 범위를 초과한 숫자를 저장할때 발생하는 현상이다
	// 오버플로우가 발생하면 최상위 비트(MSB) 를 덮어쓰므로 잘못된 결과를 리턴한다.
	// C언어는 false = 0
	// 그 외 값들은 참으로 인식한다
	
	// 그 외 값들이 참이라는건 1 도 참 -1 도 참 즉 음수를 포함해
	// 0 이 아닌 값들은 전부 참이라고 한다.

	// 삼항 연산자는
	// 조건식 ? 반환값1 : 반환값2
	// 앞의 조건식이 참이라면 반환값 1 을 반환하고
	// 앞의 조건식이 거짓이라면 반환값 2를 반환한다

	int num01= 15;
	int num02= 8;
	result = (num01 > num02) ? num01:num02;

	printf("둘 중에 더 큰 수는 %d 입니다.\n", result);

	// & (앰퍼샌드) = 주소연산자
	

	int i;
	int except_num = 3;

	for (i = 0; i <= 100; i++) {
		if (i % except_num == 0) {
			continue;
		}
		print("%d", i);
	}

	while(1) {
		sum += start_num;
		if (start_num == end_num) {
			break
		}
		start_num ++;
	}
}


int i, j;


int gop(){
	for(i = 2; i <= 9; i++) {
		for(j = 1 j <=9; j++) {
			printf("%d x %d = %d\n", i, j, i*j);
			if (i == j) {
				printf("\n");
				// 가장 가까운 for문을 종료
				break;
			}
		}
	}
}

// c 언어의 함수.

int bignum(int num1, int num2) {
	if (num1 == num2) {
		return num1;
	} else {
		return num2;
	}

}


int main(void) {
	int result;

	result = bignum(3, 5)

	if result == 3	
}

// c언어에서는 가장 먼저 main() 함수가 컴파일러에 의해 컴파일된다
// 위와 같은 코드에 바로 bignum 함수를 대입 시킨다면
// 컴파일 오류를 일으킨다
// 왜냐하면 아직 컴파일러는 bignum() 함수의 존재를 모르기 때문이다.

int bignum(int, int);

// global scope 전역변수를 설정하는 방법
int var;

int main(void) {
	int result;

	result = bignum()
}

// 와 같은 코드로 사용을 해야
// 컴파일러 오류를 일으키지 않는다.

// 같은 변수가 여러번 데이터가 변경이 된다면
// 블록 기준 {} 으로 블록안에서 값을 변경하고 난뒤
// {} 블록이 끝난다면 모든 지역변수는 메모리에서 사라지게 된다


// {} 밖에 선언하는건 global scope
// {} 내부에 선언하는건 local scope

// 정적변수는 static 키워드로 선언한걸 말하는데 static int googd = 1;
// 이렇게 선언하는게 정적변수라고 한다.

// 이렇게 선언된 정적변수는 지역변수와 전역변수의 특징을 모두 가지게 된다

// 함수 내에서 선언된 정적변수는 전역 변수 처럼 단 한번만 초기화 되며
// 즉 한번만 초기화되고 프로그램이 종료 될때 까지 메모리상에 남아있는데
// 아까전에 {} 에서 선언한 지역변수는 {} 끝남 과 동시에 메모리에서 값이 사라진다.

