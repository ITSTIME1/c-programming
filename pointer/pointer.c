#include <stdio.h>

int main() {
	int *p = NULL;

	int num = 10;

	p = &num;

	// 이게 포인터 p의 값
	printf("연산자 : %d", *p);
	// 이게 포인터 p의 주소값
	printf("연산자 : %d", p);



	// *p 와 p의 차이점이라면
	// *p 는 처음에 포인터 변수로 선언을해
	// 해당 변수에는 주소값이 들어갈 수 있다
	// 아래 p 에다가 num이라는 값의 주소값을 넣었다
	// 이때 *p 이 형태는 p에 저장되어 있는 주소값을 찾아가서 해당 주소값의 실제 저장되어 있는 int, double 과 같은 값을 출력하라는 의미가된다
	// 반면 p라는 값을 출력하게 되면 이건 p의 들어있는 "주소값"을 출력하라는 의미가 되기 때문에 주소값의 저장되어 있는 값이 아닌 주소값이 출력되게 되는 것이다.



	// 그럼 포인터 연산을 할때
	// (*p)++;
	// *p++; 의 차이는 무엇일까 똑같은 증감연산을 하는건데
	// 무엇이 다르길래 두개의 값이 다른 값이 나오는 것일까
	// 예상대로라면 만약 *p = 10 이라면 둘다 11이 출력되어야 정상인데
	// 그렇게 출력 되지 않고 아래것만 제대로 출력된 이유는 연산의 순위가 있기 때문이다


	// 우선 증감연산자 가 (*) 참조연산자보다 우선순위가 높다
	// 때문에 *p++ 같은 경우 참조연산자와 증감연산자 두개가 동시에 있을때
	// 증감연산자가 우선순위가 더 높기 때문에
	// *p 메모리의 주소를 따라가 값을 참조하지 않고
	// 먼저 ++ 증감부터 하고 난 뒤에 값을 참조하는 방식이 되어버린다

	// 그럼 생각해보면 원래 메모리의 주소값을 찾아가서 그 값을 증가시키는건데
	// 참조가 우선순위가 더 늦다 보니까 미리 메모리의 주소값을 증가 시켰기 때문에

	// 그럼 참조를 하는게 아닌 메모리의 주소값이 증가하게 되는건데

	// 증가시킨 그 주소에는 아무값도 들어있찌 않기 때문에
	// 결과적으로 증가시킨 메모리의 주소값은 아무값도 들어있찌 않기 때문에
	// 참조하게 되었을때 아무값도 없는 쓰레기값의 메모리주소의 값을 가르키고 있는 것이다.


	// 때문에
	// *p++ 이상한 값이 출력되게 되는 것.

	// 그럼 위의(*p)++ 값은 수학연산과 같이 ()값이 있으면 괄호부터 먼저 계산하는 우선순위를 갖게 된다

	// 때문에 참조연산부터 진행하고 증감연산을 진행해라 라는 뜻이 된다.

	// 때문에 메모리주소의 값을 참조해서 그 값을 가지고 있는다음에 ++ 연산을 진행한다면 기대하는 값이 출력되는걸 볼 수 있다.
	// 사실 위 두 방법이 서로 틀렸다고 말할 순 없다 누군가는
	// 의도적으로 쓰레기값을 먼저 증가시킨다음에 해당 값을 참조하게 끔 만들 수 도 있고, 그 의도는 모르겠지만
	// 때문에 이런 차이가 있다 정도만 알면 될거 같다.
	
	return 0;
}