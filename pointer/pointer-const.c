#include <stdio.h>

int main() {
	
	// const 키워드를 사용하면 포인터가 가리키는 변수를 상수화 시킨다
	// const 자체가 상수라는 뜻 자체를 지니고 있기 때문에
	// const 키워드가 붙는 순간 그 자료형은 값이 변경되지 않는다.

	int num = 10;
	int *ptr1 = &num;
	const int *ptr2 = &num;


	*ptr1 = 20;
	num = 30;
	// error
	*ptr2 = 40;
	// 첫번째는 int형인 변수 num 에 10이라는 자연수를 할당해준거고
	// 두번째 포인터변수1은 num의 주소값을 넣어주고 있고
	// 세번째는 const 키워드가 붙은 포인터변수2 에 num의 주소값을 넣어주고 있다.


	// 그럼 위와 같은 상황이 존재한다고 했을때
	// 오류가나는 곳은 어디일까 ?
	// 바로 const 키워드가 붙은 40을 할당하려고 했을때 오류를 나타내게 된다
	// 그 이유는 포인터변수1에 20을 할당하는건 const 키워드가 없기 때문의 값의 변경은가능하다
	// 그럼 num = 30을 넣는건 왜 가능할까?
	// const 키워드가 포인터변수 앞에 붙었다고 해서 num 변수 자체의 값 까지 const 화가 된건 아니다
	// const 가 된건 *ptr2 만 const 화가 된 것이기 때문에
	// num의 값은 변경이 가능하다.
	// 단 포인터변수2의 값을 변경하려고 한다면 const 화가 되어 있기 때문에
	// 값의 변경이 불가능하다는걸 알아볼 수 있다.


	// 1. 포인터변수 값을 상수화
	const int *ptr = &num;
	// 2. 포인터변수 자체를 상수화
	// 처음에 포인터 선언을 하는걸 배웠을때
	// *포인터연산자는 위치가 어디에도 상관이 없었따
	// int* int * ptr int *ptr 이나 상관이 없었찌만
	// const 화 시킬때는 예외로
	// * 연산자의 순서가 굉장히 중요하게 된다.
	// 만약 포인터자체를 상수화 시킨다고 했을때 (메모리주소 값도 변경이 불가능하도록 만들때)
	// const 전에 int* 형식으로 작성을 해주어야 포인터변수의 메모리 주소값을 변경하지 못하게 된다.


	// 따라서 이렇게 선언함과 동시에 ptr2 라는 포인터변수는 메모리의 주소값을 변경하지 못하는 const 화 되어있는 상태기 때문에
	// 단 이렇게 선언하면 메모리의주소값만 변경되지 않는거지 포인터변수를 이용해서 값을 변경하는건 가능하다
	// *ptr2 = 30 이런식으로 값의 변경이 가능하지만 메모리의 주소는 항상 num 의 메모리의주소 값만 가리키 겠다 라는것이다.

	int* const ptr2 = &num;

	// 3. 만약 포인터를 통해서 값을 변경하는 것도 메모리의 주소값도 변경하는걸 막게 하고 싶다면
	const int* const ptr2 = &num;	
	return 0;	
}
